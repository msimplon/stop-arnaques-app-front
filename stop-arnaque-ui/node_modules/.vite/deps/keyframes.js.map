{
  "version": 3,
  "sources": ["../../lerp/index.js", "../../lerp-array/index.js", "../../unlerp/index.js", "../../gl-vec3/set.js", "../../keyframes/index.js"],
  "sourcesContent": ["function lerp(v0, v1, t) {\n    return v0*(1-t)+v1*t\n}\nmodule.exports = lerp", "var lerp = require('lerp')\n\nmodule.exports = function lerpValues(value1, value2, t, out) {\n    if (typeof value1 === 'number'\n            && typeof value2 === 'number')\n        return lerp(value1, value2, t)\n    else { //assume array\n        var len = Math.min(value1.length, value2.length)\n        out = out||new Array(len)\n        for (var i=0; i<len; i++) \n            out[i] = lerp(value1[i], value2[i], t)\n        return out\n    }\n}", "module.exports = function range(min, max, value) {\n  return (value - min) / (max - min)\n}", "module.exports = set;\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\nfunction set(out, x, y, z) {\n    out[0] = x\n    out[1] = y\n    out[2] = z\n    return out\n}", "//Generic list of keyframes with timestamps and values\n\nvar lerp = require('lerp-array')\nvar range = require('unlerp')\nvar vec3 = require('gl-vec3/set')\n\nvar temp = [0, 0, 0]\n\nfunction sort(a, b) {\n    return a.time - b.time\n}\n\nfunction Keyframes(frames, sorted) {\n    if (!(this instanceof Keyframes)) \n        return new Keyframes(frames, sorted)\n    this.frames = frames||[]\n    if (!sorted)\n        this.sort()\n}\n\n//Finds the index of the nearest keyframe to the given time stamp.\n//If radius is specified, it will return the nearest only within that radius\nKeyframes.prototype.nearestIndex = function(time, radius) {\n    radius = typeof radius === 'number' ? radius : Number.MAX_VALUE\n    var minDist = Number.MAX_VALUE\n    var nearest = -1\n    for (var i=0; i<this.frames.length; i++) {\n        var dist = Math.abs(this.frames[i].time - time)\n        if (dist < minDist && dist <= radius) {\n            minDist = dist\n            nearest = i\n        }\n    }\n    return nearest\n}\n\n//Gets the keyframe at the index\nKeyframes.prototype.nearest = function(time, radius) {\n    var idx = this.nearestIndex(time, radius)\n    return idx === -1 ? null : this.frames[idx]\n}\n\n//Gets the keyframe at time\nKeyframes.prototype.get = function(time) {\n    return this.nearest(time, 0)\n}\n\n//Gets the keyframe index at time\nKeyframes.prototype.getIndex = function(time) {\n    return this.nearestIndex(time, 0)\n}\n\n//lerps the value at the specified time stamp\n//returns null if no keyframes exist\nKeyframes.prototype.value = function(time, interpolator, out) {\n    var v = this.interpolation(time)\n    if (v[0] === -1 || v[1] === -1)\n        return null\n\n    var startFrame = this.frames[ v[0] ]\n    var endFrame = this.frames[ v[1] ]\n    var t = v[2]\n    \n    //We interpolator from left keyframe to right, with a custom easing\n    //equation if specified\n    if (typeof interpolator === 'function')\n        return interpolator(startFrame, endFrame, t, out)\n\n    //Otherwise we assume the values are simple numbers and lerp them\n    return lerp(startFrame.value, endFrame.value, t, out)\n}\n\nKeyframes.prototype.interpolation = function(time) {\n    if (this.frames.length === 0)\n        return vec3(temp, -1, -1, 0)\n\n    var prev = -1\n    //get last keyframe to time\n    for (var i=this.frames.length-1; i>=0; i--) {\n        if (time >= this.frames[i].time) {\n            prev = i\n            break\n        }\n    }\n    \n    //start or end keyframes\n    if (prev === -1 || prev === this.frames.length-1) {\n        if (prev < 0)\n            prev = 0\n        return vec3(temp, prev, prev, 0)\n    } \n    else {\n        var startFrame = this.frames[prev]\n        var endFrame = this.frames[prev+1]\n\n        //clamp and get range\n        time = Math.max(startFrame.time, Math.min(time, endFrame.time))\n        var t = range(startFrame.time, endFrame.time, time)\n\n        //provide interpolation factor\n        return vec3(temp, prev, prev+1, t)\n    }\n}\n\nKeyframes.prototype.next = function(time) {\n    if (this.frames.length < 1)\n        return null\n\n    var cur = -1\n    //get last keyframe to time\n    for (var i=0; i<this.frames.length; i++) {\n        if (time < this.frames[i].time) {\n            cur = i\n            break\n        }\n    }\n    return cur===-1 ? null : this.frames[cur]\n}\n\nKeyframes.prototype.previous = function(time) {\n    if (this.frames.length < 1)\n        return null\n\n    var cur = -1\n    //get last keyframe to time\n    for (var i=this.frames.length-1; i>=0; i--) {\n        if (time > this.frames[i].time) {\n            cur = i\n            break\n        }\n    }\n    return cur===-1 ? null : this.frames[cur]\n}\n\n//Adds a frame at the given time stamp\nKeyframes.prototype.add = function(frame) {\n    this.frames.push(frame)\n    this.sort()\n}\n\n//convenience for .frames.splice\n//if items are inserted, a sort will be applied after insertion\nKeyframes.prototype.splice = function(index, howmany, itemsN) {\n    this.frames.splice.apply(this.frames, arguments)\n    if (arguments.length > 2)\n        this.sort()\n}\n\n//sorts the keyframes. you should do this after \n//adding new keyframes that are not in linear time\nKeyframes.prototype.sort = function() {\n    this.frames.sort(sort)\n}\n\n//Clears the keyframe list\nKeyframes.prototype.clear = function() {\n    this.frames.length = 0\n}\n\nObject.defineProperty(Keyframes.prototype, \"count\", {\n    get: function() {\n        return this.frames.length\n    }\n})\n\nmodule.exports = Keyframes"],
  "mappings": "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",
  "names": []
}

import {
  __commonJS
} from "./chunk-RSJERJUL.js";

// node_modules/lerp/index.js
var require_lerp = __commonJS({
  "node_modules/lerp/index.js"(exports, module) {
    function lerp(v0, v1, t) {
      return v0 * (1 - t) + v1 * t;
    }
    module.exports = lerp;
  }
});

// node_modules/lerp-array/index.js
var require_lerp_array = __commonJS({
  "node_modules/lerp-array/index.js"(exports, module) {
    var lerp = require_lerp();
    module.exports = function lerpValues(value1, value2, t, out) {
      if (typeof value1 === "number" && typeof value2 === "number")
        return lerp(value1, value2, t);
      else {
        var len = Math.min(value1.length, value2.length);
        out = out || new Array(len);
        for (var i = 0; i < len; i++)
          out[i] = lerp(value1[i], value2[i], t);
        return out;
      }
    };
  }
});

// node_modules/unlerp/index.js
var require_unlerp = __commonJS({
  "node_modules/unlerp/index.js"(exports, module) {
    module.exports = function range(min, max, value) {
      return (value - min) / (max - min);
    };
  }
});

// node_modules/gl-vec3/set.js
var require_set = __commonJS({
  "node_modules/gl-vec3/set.js"(exports, module) {
    module.exports = set;
    function set(out, x, y, z) {
      out[0] = x;
      out[1] = y;
      out[2] = z;
      return out;
    }
  }
});

// node_modules/keyframes/index.js
var require_keyframes = __commonJS({
  "node_modules/keyframes/index.js"(exports, module) {
    var lerp = require_lerp_array();
    var range = require_unlerp();
    var vec3 = require_set();
    var temp = [0, 0, 0];
    function sort(a, b) {
      return a.time - b.time;
    }
    function Keyframes(frames, sorted) {
      if (!(this instanceof Keyframes))
        return new Keyframes(frames, sorted);
      this.frames = frames || [];
      if (!sorted)
        this.sort();
    }
    Keyframes.prototype.nearestIndex = function(time, radius) {
      radius = typeof radius === "number" ? radius : Number.MAX_VALUE;
      var minDist = Number.MAX_VALUE;
      var nearest = -1;
      for (var i = 0; i < this.frames.length; i++) {
        var dist = Math.abs(this.frames[i].time - time);
        if (dist < minDist && dist <= radius) {
          minDist = dist;
          nearest = i;
        }
      }
      return nearest;
    };
    Keyframes.prototype.nearest = function(time, radius) {
      var idx = this.nearestIndex(time, radius);
      return idx === -1 ? null : this.frames[idx];
    };
    Keyframes.prototype.get = function(time) {
      return this.nearest(time, 0);
    };
    Keyframes.prototype.getIndex = function(time) {
      return this.nearestIndex(time, 0);
    };
    Keyframes.prototype.value = function(time, interpolator, out) {
      var v = this.interpolation(time);
      if (v[0] === -1 || v[1] === -1)
        return null;
      var startFrame = this.frames[v[0]];
      var endFrame = this.frames[v[1]];
      var t = v[2];
      if (typeof interpolator === "function")
        return interpolator(startFrame, endFrame, t, out);
      return lerp(startFrame.value, endFrame.value, t, out);
    };
    Keyframes.prototype.interpolation = function(time) {
      if (this.frames.length === 0)
        return vec3(temp, -1, -1, 0);
      var prev = -1;
      for (var i = this.frames.length - 1; i >= 0; i--) {
        if (time >= this.frames[i].time) {
          prev = i;
          break;
        }
      }
      if (prev === -1 || prev === this.frames.length - 1) {
        if (prev < 0)
          prev = 0;
        return vec3(temp, prev, prev, 0);
      } else {
        var startFrame = this.frames[prev];
        var endFrame = this.frames[prev + 1];
        time = Math.max(startFrame.time, Math.min(time, endFrame.time));
        var t = range(startFrame.time, endFrame.time, time);
        return vec3(temp, prev, prev + 1, t);
      }
    };
    Keyframes.prototype.next = function(time) {
      if (this.frames.length < 1)
        return null;
      var cur = -1;
      for (var i = 0; i < this.frames.length; i++) {
        if (time < this.frames[i].time) {
          cur = i;
          break;
        }
      }
      return cur === -1 ? null : this.frames[cur];
    };
    Keyframes.prototype.previous = function(time) {
      if (this.frames.length < 1)
        return null;
      var cur = -1;
      for (var i = this.frames.length - 1; i >= 0; i--) {
        if (time > this.frames[i].time) {
          cur = i;
          break;
        }
      }
      return cur === -1 ? null : this.frames[cur];
    };
    Keyframes.prototype.add = function(frame) {
      this.frames.push(frame);
      this.sort();
    };
    Keyframes.prototype.splice = function(index, howmany, itemsN) {
      this.frames.splice.apply(this.frames, arguments);
      if (arguments.length > 2)
        this.sort();
    };
    Keyframes.prototype.sort = function() {
      this.frames.sort(sort);
    };
    Keyframes.prototype.clear = function() {
      this.frames.length = 0;
    };
    Object.defineProperty(Keyframes.prototype, "count", {
      get: function() {
        return this.frames.length;
      }
    });
    module.exports = Keyframes;
  }
});
export default require_keyframes();
//# sourceMappingURL=keyframes.js.map
